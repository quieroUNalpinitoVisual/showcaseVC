[{"id":0,"href":"/showcasevc/docs/shortcodes/masking/","title":"Masking","section":"Shortcodes","content":"Masking #  En esta tem√°tica se desarroll√≥ un entorno de ejecuci√≥n para visualizar los efectos de algunos kernels en matrices de convolucion sobre imagenes para su posterior uso como base en un algoritmo que calcula los bordes de las mismas im√°genes mediante derivadas parciales en dos variables.\n"},{"id":1,"href":"/showcasevc/docs/shortcodes/masking/maskingLab/","title":"Masking Lab","section":"Masking","content":"Masking Lab #  Seccion de pruebas de matrices de convolucion como paso intermedio para el c√°lculo de bordes mediante derivadas parciales.\n        "},{"id":2,"href":"/showcasevc/docs/shortcodes/masking/maskingRes/","title":"Masking Res","section":"Masking","content":"Masking Results #  Conceptos #  Lo primero que se realiz√≥ fue programar la funci√≥n que permitir√° la convoluci√≥n de un kernel sobre una imagen de acuerdo con lo encontrado en wikipedia\n Expand ‚Üï  Wiki pseudocode #  for each image row in input image: for each pixel in image row: set accumulator to zero for each kernel row in kernel: for each element in kernel row: if element position corresponding* to pixel position then multiply element value corresponding* to pixel value add result to accumulator endif set output image pixel to accumulator     la implementaci√≥n concreta es la siguiente\n Expand ‚Üï  p5 code #  p.convolute = function (matrix){ img.loadPixels(); let rtotal = 0.0; let gtotal = 0.0; let btotal = 0.0; let postconv = p.createImage(400,400); for (let i = 1; i \u0026lt; 399; i++){ for (let j = 1; j \u0026lt; 399; j++){ rtotal = 0.0; gtotal = 0.0; btotal = 0.0; for (let k = -1; k \u0026lt;= 1; k++){ for (let l = -1; l \u0026lt;= 1; l++){ let xpos = i+k; let ypos = j+l; let red = p.red(img.get(xpos,ypos)); let green = p.blue(img.get(xpos,ypos)); let blue = p.green(img.get(xpos,ypos)); rtotal += red * matrix[k+1][l+1]; gtotal += green * matrix[k+1][l+1]; btotal += blue * matrix[k+1][l+1]; } } rtotal = p.constrain(rtotal, 0, 255); gtotal = p.constrain(gtotal, 0, 255); btotal = p.constrain(btotal, 0, 255); let c = p.color(rtotal,gtotal,btotal); postconv.set(i,j,c); } } postconv.updatePixels(); img = postconv; img.updatePixels(); p.square(0,200,400); p.drawimg(img,0,200); console.log('convolucion realizada! :D'); }     Una derivada parcial nos indica como se mueve la pendiente en ese punto para la funcion (imagen)\nhttps://mathinsight.org/partial_derivative_limit_definition\nImagenes convolucionadas y bordes #  imagen base: #  identidad / sin mascara : #  sharpen : #  ridge : #  box blur: #  composition: #  "},{"id":3,"href":"/showcasevc/docs/shortcodes/members/","title":"Members","section":"Shortcodes","content":"Members #  Nicholson Stive Ochoa #  Estudiante de Ingenieria de Sistemas y Computacion en la Universidad Nacional de Colombia.\nIntereses ü§î #   Acad√©micos üìò    Desarrollo web Inteligencia artificial Desarrollo en multiplataforma    Pasatiempos üéÆüé∏    Ver anime y series Hacer ejercicio    Daniel Arturo Moreno #  Estudiante de Ingenieria de Sistemas y Computacion en la Universidad Nacional de Colombia.\nIntereses ü§î #    Acad√©micos üìò\n Desarrollo Web Arduino Linux Procesamiento de im√°genes Programaci√≥n Competitiva y Algoritmia    Pasatiempos üéÆüé∏\n Geoguessr RPGs M√∫sica     Johan Sebastian Romero #  Estudiante de Ingenieria de Sistemas y Computacion en la Universidad Nacional de Colombia.\nIntereses ü§î #    Acad√©micos üìò\n Desarrollo Web Procesamiento de imagenes Arquitectura de software    Pasatiempos üéÆüé∏\n Videojuegos (Wow) Motociclismo off road Anime      "},{"id":4,"href":"/showcasevc/docs/shortcodes/terrain/","title":"Terrain","section":"Shortcodes","content":"Creating a terrain with p5.js #  Academic report #  Introducci√≥n: #  En el marco de trabajo presentado por el profesor en clase, que enmarcaba varios tipos de ilusiones, nos llam√≥ la atenci√≥n el titulado MACH BANDS , el cual se enfocaba en la generaci√≥n de un terreno con una superficie natural con la aplicaci√≥n del efecto nombrado.\nPara lograr el objetivo utilizamos la libreria p5.js, la cual utilizaremos posiblemente durante los proyectos del semestre por recomendaci√≥n del profesor y no valemos de una libreria integrada de p5 llamada Perlin noise para tratar de generar una textura natural para el terreno.\nLiteratura: #  p5.js: #  Es una biblioteca de JavaScript para la codificaci√≥n creativa, con un enfoque en la realizaci√≥n de la codificaci√≥n accesible e inclusiva para artistas, dise√±adores, educadores, principiantes y cualquier otra persona. P5.js es gratuito y de c√≥digo abierto porque la filosofia de los creadores es que el software, y las herramientas para aprenderlo, deben ser accesibles para todos.(p5js.org)\nPerlin noise #  Es un generador de secuencias aleatorias que produce una sucesi√≥n de n√∫meros arm√≥nicos ordenados de forma m√°s natural en compraci√≥n con la funci√≥n est√°ndar aleatoria (). Fue inventado por Ken Perlin en la d√©cada de 1980 y se ha utilizado desde aplicaciones gr√°ficas para producer textura de procedimiento, movimiento natural, formas, terrenos, etc. (p5js.org)\nLa mayor diferencia con random() es que perlin noise se define en un espacio N-dimensional infinito donde cada par de coordenadas corresponde a un valor semi-aleatorio fijo.\nMetodos #    Terrain1  Terrain # En el primer terreno creado usamos TRIANGLE_STRIP como parametro para la funci√≥n beginShape() \"   Terrain3  Terrain # Por ultimo utilizamos el parametro TRIANGLE_FAN. \"   Terrain Res  #Terrain Con TRIANGLE_STRIP la figura a manejar es mas grande y por ende se utilizan menos recursos. Pero el relleno es mas complicado. Con TRIANGLE_FAN la figura a manejar es mas peque√±a y por ende se utilizan mas recursos. Pero el relleno es mas detallado y natural.   "},{"id":5,"href":"/showcasevc/docs/shortcodes/terrain/terrain1/","title":"Terrain1","section":"Terrain","content":"Terrain #  En el primer terreno creado usamos TRIANGLE_STRIP como parametro para la funci√≥n beginShape()\n          \"  "},{"id":6,"href":"/showcasevc/docs/shortcodes/terrain/terrain3/","title":"Terrain3","section":"Terrain","content":"Terrain #  Por ultimo utilizamos el parametro TRIANGLE_FAN.\n          \"  "},{"id":7,"href":"/showcasevc/docs/shortcodes/terrain/terrainRes/","title":"Terrain Res","section":"Terrain","content":"#Terrain\nCon TRIANGLE_STRIP la figura a manejar es mas grande y por ende se utilizan menos recursos.\nPero el relleno es mas complicado.\nCon TRIANGLE_FAN la figura a manejar es mas peque√±a y por ende se utilizan mas recursos.\nPero el relleno es mas detallado y natural.\n"}]