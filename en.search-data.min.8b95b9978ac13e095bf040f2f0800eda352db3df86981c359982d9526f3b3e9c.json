[{"id":0,"href":"/showcasevc/docs/shortcodes/Antialiasing/","title":"Antialiasing","section":"Shortcodes","content":" Antialiasing # Se desea trabajar en una implementacion del algoritmo de antialiasing y estudiar sus fenomenos.\n"},{"id":1,"href":"/showcasevc/docs/shortcodes/Antialiasing/AntialiasingLab/","title":"Antialiasing Lab","section":"Antialiasing","content":" Masking Lab # Seccion de pruebas de antialiasing.\nFlecha derecha: Generar nuevo triangulo\nFlecha izquierda: Pasar antialiasing\n"},{"id":2,"href":"/showcasevc/docs/shortcodes/Antialiasing/AntialiasingRes/","title":"Antialiasing Res","section":"Antialiasing","content":" Academic report # Introducción: # El Antialiasing (suavizado, antiescalonamiento o suavizado de bordes) son un conjunto de tecnicas diferentes las cuales quieren evitar el solapamiento de los bordes debida a representar una señal de alta resolución en un monitor de baja resolución.\nLiteratura: # Métodos de AA: # Para lograr el efecto del antialiasing se realizan varios métodos con distintas aproximaciones:\nSuper sampling:\nBasicamente consiste en realizar un análogo de el muestreo de una señal analoga y aumentar el muestreo de la misma para obtener mejores datos. Multi-sampling:\nSe parece al algoritmo de super sampling pero difiere con el al momento de calculo de cada pixel, donde en SSAA se realizan varios calculos por pixel, en MSAA se realiza solo un calculo por pixel.\nEdge AA:\nEs un método propuesto por Deferred Shading en STALKER. En este se realiza primero un calculo de bordes de una imagen y a partir de esto se usa como máscara para saber en que lugares se debe realizar el algoritmo de AA. AA Morfológico:\nEn este método de dividen las areas de pixeles con colores similares en 3 tipos: Z, L y U. Tanto Z como U se pueden componer de tipos L. Ya con las areas de tipo L distinguidas usa modelado de triangulos para realizar el calculo del antialiasing.\nDeep Learning Super Sample:\nEste algortimo desarrollado por Nvidia hace uso de los subprocesadores de tipo Tensor en las nuevas graficas de la compañia para implementar Super Sampling mediante una IA. AMD FidelityFX Contrast Adaptive Sharpening:\nEste algoritmo de antialiasing temporal es desarrollado por AMD technologies y posee una base de codigo abierto para su uso. Ademas de proveer antialiasing, tambien posee funciones de escalamiento y sharpening.\nImplementación # En el apartado de AntialiasingLab se puede encontrar un ejemplo de implementacion de SSAA basado en la facilidad que tenemos de obtener la referencia real de la figura que estamos modelando, en este caso es un triángulo aleatorio que se dibuja en una cuadrilla.\nEn la funcion que describimos a continuacion en el expandible encontramos los loops que recorren la simulacion de una imagen de mas alta resolución (64 a 1) y van hayando donde el triangulo discreto (en este caso dibujado con la funcion de Quadrille.js) y el triangulo real que se dibuja con la primitiva triangle() de p5. Damos un peso relativo de acuerdo a cuantos pixeles de la imagen de alta resolucion poseen el triangulo y lo dibujamos luego en la cuadrilla de menor resolución\nExpand ↕ p5 code # function supersamp(){ let total = 64; for (let i = 0; i \u0026lt; QUADDIM ; i ++) { for (let j = 0; j \u0026lt; QUADDIM ; j ++) { let count = 0; let si = LENGTH * i +1; let sj = LENGTH * j + 1; for (; si \u0026lt; LENGTH * i + LENGTH - 1 ; si ++) { for (; sj \u0026lt; LENGTH * j + LENGTH - 1 ; sj ++) { if(get(si,sj)[0] != 0){ count += 1; } } } let shade = (count/total)*10; board._memory2D[j][i]=[red(0), green(255*shade), blue(0), alpha(255)]; } } } Resultados # Pre AA\nPost AA\nConclusiones # El algoritmo es capaz de ser paralelizable para un mejor rendimiento. Dada la base tan robusta y sencilla del SS este ha derivado en otros métodos como el DLSS. La información inicial deberia ser capaz de obtenerse sin bordes para dibujarlos con AA (QuadrilleJS en los bordes \u0026ldquo;ïnferiores\u0026rdquo;). Junto con el calculo de bordes daria un muy buen resultado con el algoritmo de Edge AA. Entre mucho mayor sea la resolucion del super sampling, se obtienen profundidades de colores intermedias mas precisas, pero llega un punto en que no se notara la diferencia. Referencias # Algoritmos de antialiasing - Gabriel Mañana Guichón Nvidia DLSS AMD FidelityFx CAS Mas algoritmos de Antialiasing QuadrilleJS\n"},{"id":3,"href":"/showcasevc/docs/shortcodes/Interactions-3D/","title":"Interactions 3 D","section":"Shortcodes","content":" Investigación sobre interacciónes de usuario en 3D # (A Survey of Interaction Techniques for Interactive 3D Environments) - Jacek Jankowski, Martin Hachet\nAcademic report # Introducción: # Teniendo en cuenta la tematica adelantada en clase, y su amplio espectro, decidimos enfocarnos en las interacciones de usuario en 3D. Mas especificamente las interacciones hombre maquina dentro de un espacio virtual simulado en la computadora. Y es que a pesar de que todos hemos crecido y vivido en un entorno 3D y por tanto hemos desarrollado habilidades para interactuar en el mismo, a menudo nos resulta difícil interacturar en entronos 3D interactivos, y segun Jankowski[1] frecuentemente esto es resultado de una interfaz de usuario mal diseñada o debido a una selección inadecuada de técnicas de interacción.\nLiteratura: # Entornos 3D: # Se definen los entornos 3D interactivos como representaciones informáticas del mundo real o espacios imaginarios a través de los cuales los usuarios pueden navegar y en los que pueden interacturar con objetos en tiempo real. A diferencia de los entornos virtuales inmersivos , que utilizan pantallas especializadas y dispositivos de interacción, como pantallas montadas en la cabeza, para crear una sensación de presencia para los usuarios dentro del mundo virtual, los entornos 3D interactivos no se limitan al contexto inmersivo y aprovechan los recursos comunes y general de hardware, es decir mouse y teclado como multi_touch input.\nTendremos en cuenta la clasificación de las interacciones en un ambiente interactivo 3D que encontramos en el libro de Jankowski[1] que habla de 3 tareas de interaccion universales: Navegación, Selección y manipulación, y Control de sistema.\nNavegación: # Se refiere a la tarea motora de mover el punto de vista del usuario a través de un entorno; incluye un componente cognitivo: orientación.\nLos entornos 3D interactivos suelen representar más espacio del que se puede ver desde un solo punto. Los usuarios deben poder moverse dentro del entorno para obtener diferentes vistas de la escena. Este proceso de desplazarse por un entorno virtual mientras se realiza un seguimiento del propio paradero y los objetivos de la tarea es el tema de una serie de técnicas a las que a menudo se hace referencia con nombres como orientación, locomoción, navegación y cámara.\nHay que resaltar que es difícil desarrollar una técnica eficaz para la navegación en entornos 3D interactivos. En primer lugar, el control del punto de vista implica seis grados de libertad (6DOF): tres dimensiones para la ubicación posicional (traslación) y tres para la ubicación angular (rotación).\nSegun algunas literaturas podemos agrupoar 4 tipos de movimiento de punto de vista para espacios de trabajo 3D interactivos:\nMovimiento general: Movimiento exploratorio, como caminar a través de una simulación de un diseño arquitectónico\nMovimiento dirigido: Movimiento con respecto a un objetivo específico, como moverse para examinar un detalle de un modelo de ingeniería.\nMovimiento de coordenadas especificado: Movimiento a una posición y orientación precisas, como una posición de visualización específica en relación con un modelo CAD: el usuario debe proporcionar la posición y orientación exactas de su destino.\nMovimiento de trayectoria especificado: Movimiento a lo largo de una trayectoria de posición y orientación, como el movimiento de una cámara cinematográfica (corresponde al objetivo Maniobra de Bowman et al. y al objetivo Inspección de Tan et al.).\nSelección y manipulación: # Otra tarea típica que se realiza en un entorno virtual 3D es la selección de objetos y su manipulación directa mediante la especificación su posición, orientación y escala. Encontramos que las técnicas de interacción mas comunes en la literatura para la manipulación 3D incluyen tres tareas fundamentales: traducción de objetos (posicionamiento), rotación de objetos y escalado de objetos. Las técnicas de interacción para la manipulación 3D incluyen tres tareas fundamentales: traducción de objetos (posicionamiento), rotación de objetos y escalado de objetos.\nSeleccion de objetos: # La forma más común de seleccionar objetos en los VE de escritorio es colocar el cursor del mouse sobre un objeto dado y hacer clic en un botón del mouse. La técnica se basa en la proyección de rayos (ray casting); utiliza el rayo desde el punto del ojo a través del píxel actualmente seleccionado por el puntero del mouse para encontrar el primer punto de intersección con la escena (la superficie del objetivo o su superficie aproximada, por ejemplo, el cuadro delimitador). Si el rayo virtual se cruza con un objeto, se puede seleccionar para una mayor manipulación.\nManipulación de objeto: # La manipulación de objetos es otra tarea básica que se realiza en un entorno virtual 3D, especialmente durante la construcción de escenas. Al diseñar una escena con múltiples objetos, los usuarios tienen que realinear y ajustar varias partes repetidamente. Es importante proporcionar una técnica de manipulación de objetos eficiente.\nControl del sistema: # Se refiere a la comunicación entre el usuario y el sistema que no forma parte del entorno virtual.\nSe puede enfocar en una tarea en la que se aplica un comando para cambiar el estado del sistema o el modo de interacción .Se señala que aunque el movimiento del punto de vista y la selección/manipulación se han estudiado ampliamente, se ha investigado muy poco sobre las tareas de control del sistema. Sin embargo, las técnicas de control de aplicaciones se han estudiado intensamente durante los últimos 40 años en las interfaces gráficas de usuario WIMP 2D \u0026ldquo;apuntar y hacer clic\u0026rdquo; (interfaces basadas en ventanas, íconos, menús y un dispositivo señalador, generalmente un mouse).\n# Metodos # "},{"id":4,"href":"/showcasevc/docs/shortcodes/masking/","title":"Masking","section":"Shortcodes","content":" Masking # En esta temática se desarrolló un entorno de ejecución para visualizar los efectos de algunos kernels en matrices de convolucion sobre imagenes para su posterior uso como base en un algoritmo que calcula los bordes de las mismas imágenes mediante derivadas parciales en dos variables.\n"},{"id":5,"href":"/showcasevc/docs/shortcodes/masking/maskingLab/","title":"Masking Lab","section":"Masking","content":" Masking Lab # Seccion de pruebas de matrices de convolucion como paso intermedio para el cálculo de bordes mediante derivadas parciales.\n"},{"id":6,"href":"/showcasevc/docs/shortcodes/masking/maskingRes/","title":"Masking Res","section":"Masking","content":" Masking Results # Conceptos # Lo primero que se realizó fue programar la función que permitirá la convolución de un kernel sobre una imagen de acuerdo con lo encontrado en wikipedia\nExpand ↕ Wiki pseudocode # for each image row in input image: for each pixel in image row: set accumulator to zero for each kernel row in kernel: for each element in kernel row: if element position corresponding* to pixel position then multiply element value corresponding* to pixel value add result to accumulator endif set output image pixel to accumulator la implementación concreta es la siguiente\nExpand ↕ p5 code # p.convolute = function (matrix){ img.loadPixels(); let rtotal = 0.0; let gtotal = 0.0; let btotal = 0.0; let postconv = p.createImage(400,400); for (let i = 1; i \u0026lt; 399; i++){ for (let j = 1; j \u0026lt; 399; j++){ rtotal = 0.0; gtotal = 0.0; btotal = 0.0; for (let k = -1; k \u0026lt;= 1; k++){ for (let l = -1; l \u0026lt;= 1; l++){ let xpos = i+k; let ypos = j+l; let red = p.red(img.get(xpos,ypos)); let green = p.green(img.get(xpos,ypos)); let blue = p.blue(img.get(xpos,ypos)); rtotal += red * matrix[k+1][l+1]; gtotal += green * matrix[k+1][l+1]; btotal += blue * matrix[k+1][l+1]; } } rtotal = p.constrain(rtotal, 0, 255); gtotal = p.constrain(gtotal, 0, 255); btotal = p.constrain(btotal, 0, 255); let c = p.color(rtotal,gtotal,btotal); postconv.set(i,j,c); } } postconv.updatePixels(); img = postconv; img.updatePixels(); p.square(0,200,400); p.drawimg(img,0,200); console.log('convolucion realizada! :D'); } Una derivada parcial nos indica como se mueve la pendiente en ese punto para la funcion (imagen)\nhttps://mathinsight.org/partial_derivative_limit_definition\ncodigo de detección de bordes:\nExpand ↕ p5 code # p.calcborders = function(){ let prebord = p.createImage(400,400); for (let i = 0; i \u0026lt; 400; i++) { for (let j = 0; j \u0026lt; 400; j++) { let g = (p.red(img.get(i,j))+p.green(img.get(i,j))+p.blue(img.get(i,j)))/3; prebord.set(i,j,g); } } let med = [0,0,0,0,0,0,0,0,0]; for (let r = 0; r \u0026lt; 3; r++) { for (let i = 1; i \u0026lt; 400-1; i++) { for (let j = 1; j \u0026lt; 400-1; j++) { med[0] = prebord.get(i - 1,j - 1); med[1] = prebord.get(i,j - 1); med[2] = prebord.get(i + 1,j - 1); med[3] = prebord.get(i - 1,j); med[4] = prebord.get(i,j); med[5] = prebord.get(i + 1,j); med[6] = prebord.get(i - 1,j + 1); med[7] = prebord.get(i,j + 1); med[8] = prebord.get(i + 1,j + 1); med.sort(); prebord.set(i,j,med[4]); } } } let gradx = p.zeroes([400,400]); let grady = p.zeroes([400,400]); for (let i = 0; i \u0026lt; 400-1; i++) { for (let j = 0; j \u0026lt; 400-1; j++) { gradx[i][j] = p.red(img.get(i+1,j)) - p.red(img.get(i,j)); grady[i][j] = p.red(img.get(i,j+1)) - p.red(img.get(i,j)); } } let gradmag = p.zeroes([400,400]); let gradang = p.zeroes([400,400]); for (let i = 0; i \u0026lt; 400-1; i++) { for (let j = 0; j \u0026lt; 400-1; j++) { gradmag[i][j]= p.abs(p.sqrt((gradx[i][j]*gradx[i][j])+(grady[i][j]*grady[i][j]))); gradang[i][j]= p.atan2(grady[i][j],gradx[i][j]); } } let borders = p.zeroes([400,400]); for (let i = 1; i \u0026lt; 400-1; i++) { for (let j = 1; j \u0026lt; 400-1; j++) { if (gradang[i][j] \u0026gt; 0 \u0026amp;\u0026amp; gradang[i + 1][j] \u0026lt; 0) { borders[i][j] = 1; } else if (gradang[i][j] \u0026lt; 0 \u0026amp;\u0026amp; gradang[i + 1][j] \u0026gt; 0) { borders[i][j] = 1; } else if (gradang[i][j] \u0026gt; 0 \u0026amp;\u0026amp; gradang[i][j + 1] \u0026lt; 0) { borders[i][j] = 1; } else if (gradang[i][j] \u0026lt; 0 \u0026amp;\u0026amp; gradang[i][j + 1] \u0026gt; 0) { borders[i][j] = 1; } } } for (let i = 1; i \u0026lt; 400-1; i++) { for (let j = 1; j \u0026lt; 400-1; j++) { if( borders[i][j-1] == 0 \u0026amp;\u0026amp; borders[i-1][j] == 0 \u0026amp;\u0026amp; borders[i+1][j] == 0 \u0026amp;\u0026amp; borders[i][j+1] == 0 ){ borders[i][j] = 0; } } } let postbord = p.createImage(400,400); for (let i = 0; i \u0026lt; 400; i++) { for (let j = 0; j \u0026lt; 400; j++) { if (borders[i][j] == 1) { //postbord.set(i, j, p.color(0,0,0)); postbord.set(i, j, p.color(255,255,255)); } else { //postbord.set(i, j, p.color(255,255,255)); postbord.set(i, j, p.color(0,0,0)); } } } postbord.updatePixels(); console.log(prebord); console.log(postbord); bord = postbord; p.image(bord, 0, 650,400,400); } Imagenes convolucionadas y bordes # Los siguientes resultados poseen un error en la funcion de convolucion que intercambia el valor de verdes por azules y viceversa, visible en el resultado de la convolución, pero esto mismo debido a que es una permutación no afecta el calculo de bordes el cual se hace a partir de la imagen en escala de grises.\nimagen base: # identidad / sin mascara : # sharpen : # ridge : # box blur: # composition: # "},{"id":7,"href":"/showcasevc/docs/shortcodes/members/","title":"Members","section":"Shortcodes","content":" Members # Nicholson Stive Ochoa # Estudiante de Ingenieria de Sistemas y Computacion en la Universidad Nacional de Colombia.\nIntereses 🤔 # Académicos 📘 Desarrollo web Inteligencia artificial Desarrollo en multiplataforma Pasatiempos 🎮🎸 Ver anime y series Hacer ejercicio Daniel Arturo Moreno # Estudiante de Ingenieria de Sistemas y Computacion en la Universidad Nacional de Colombia.\nIntereses 🤔 # Académicos 📘\nDesarrollo Web Arduino Linux Procesamiento de imágenes Programación Competitiva y Algoritmia Pasatiempos 🎮🎸\nGeoguessr RPGs Música Johan Sebastian Romero # Estudiante de Ingenieria de Sistemas y Computacion en la Universidad Nacional de Colombia.\nIntereses 🤔 # Académicos 📘\nDesarrollo Web Procesamiento de imagenes Arquitectura de software Pasatiempos 🎮🎸\nVideojuegos (Wow) Motociclismo off road Anime "},{"id":8,"href":"/showcasevc/docs/shortcodes/shadersJohanRomero/","title":"Shaders Johan Romero","section":"Shortcodes","content":" Shaders Johan Sebastian Romero Diaz # seccion para los ejercicios propuestos para la seccion final del curso\n"},{"id":9,"href":"/showcasevc/docs/shortcodes/shadersJohanRomero/imageProcessing/","title":"Image Processing","section":"Shaders Johan Romero","content":" Image Processing # "},{"id":10,"href":"/showcasevc/docs/shortcodes/shadersJohanRomero/proceduralTexturing/","title":"Procedural Texturing","section":"Shaders Johan Romero","content":" Procedural texturing # "},{"id":11,"href":"/showcasevc/docs/shortcodes/shadersJohanRomero/texturing/","title":"Texturing","section":"Shaders Johan Romero","content":" Texturing # "},{"id":12,"href":"/showcasevc/docs/shortcodes/terrain/","title":"Terrain","section":"Shortcodes","content":" Creating a terrain with p5.js # Academic report # Introducción: # En el marco de trabajo presentado por el profesor en clase, que enmarcaba varios tipos de ilusiones, nos llamó la atención el titulado MACH BANDS , el cual se enfocaba en la generación de un terreno con una superficie natural con la aplicación del efecto nombrado.\nPara lograr el objetivo utilizamos la libreria p5.js, la cual utilizaremos posiblemente durante los proyectos del semestre por recomendación del profesor y no valemos de una libreria integrada de p5 llamada Perlin noise para tratar de generar una textura natural para el terreno.\nLiteratura: # p5.js: # Es una biblioteca de JavaScript para la codificación creativa, con un enfoque en la realización de la codificación accesible e inclusiva para artistas, diseñadores, educadores, principiantes y cualquier otra persona. P5.js es gratuito y de código abierto porque la filosofia de los creadores es que el software, y las herramientas para aprenderlo, deben ser accesibles para todos.(p5js.org)\nPerlin noise # Es un generador de secuencias aleatorias que produce una sucesión de números armónicos ordenados de forma más natural en compración con la función estándar aleatoria (). Fue inventado por Ken Perlin en la década de 1980 y se ha utilizado desde aplicaciones gráficas para producer textura de procedimiento, movimiento natural, formas, terrenos, etc. (p5js.org)\nLa mayor diferencia con random() es que perlin noise se define en un espacio N-dimensional infinito donde cada par de coordenadas corresponde a un valor semi-aleatorio fijo.\nMetodos # Terrain1 Terrain # En el primer terreno creado usamos TRIANGLE_STRIP como parametro para la función beginShape() Terrain2 Terrain # En esta iteración se hace uso del efecto de la banda de Mach para representar una ilusion de gradiente en la visualización del terreno. Terrain3 Terrain # Por ultimo utilizamos el parametro TRIANGLE_FAN. Terrain Res #Terrain Con TRIANGLE_STRIP la figura a manejar es mas grande y por ende se utilizan menos recursos. Pero el relleno es mas complicado. Con la ilusion generada por la banda de Mach encontramos un rendimiento aceptable. El efecto de relleno visual es natural exceptuando nuestro enfasis al marcar los bordes. Con TRIANGLE_FAN la figura a manejar es mas pequeña y por ende se utilizan mas recursos. Pero el relleno es mas detallado y natural. "},{"id":13,"href":"/showcasevc/docs/shortcodes/terrain/terrain1/","title":"Terrain1","section":"Terrain","content":" Terrain # En el primer terreno creado usamos TRIANGLE_STRIP como parametro para la función beginShape()\n"},{"id":14,"href":"/showcasevc/docs/shortcodes/terrain/terrain2/","title":"Terrain2","section":"Terrain","content":" Terrain # En esta iteración se hace uso del efecto de la banda de Mach para representar una ilusion de gradiente en la visualización del terreno.\n"},{"id":15,"href":"/showcasevc/docs/shortcodes/terrain/terrain3/","title":"Terrain3","section":"Terrain","content":" Terrain # Por ultimo utilizamos el parametro TRIANGLE_FAN.\n"},{"id":16,"href":"/showcasevc/docs/shortcodes/terrain/terrainRes/","title":"Terrain Res","section":"Terrain","content":"#Terrain\nCon TRIANGLE_STRIP la figura a manejar es mas grande y por ende se utilizan menos recursos.\nPero el relleno es mas complicado.\nCon la ilusion generada por la banda de Mach encontramos un rendimiento aceptable.\nEl efecto de relleno visual es natural exceptuando nuestro enfasis al marcar los bordes.\nCon TRIANGLE_FAN la figura a manejar es mas pequeña y por ende se utilizan mas recursos.\nPero el relleno es mas detallado y natural.\n"},{"id":17,"href":"/showcasevc/docs/shortcodes/Transformations/","title":"Transformations","section":"Shortcodes","content":" Creating a Matrix Transformation based cube with p5.js # Academic report # Introducción: # Durante el desarrollo del workshop, buscamos una manera didáctica de llevar a cabo una representación gráfica de la implementación de transformaciones matriciales, y finalmente se planteó que un Cubo de Rubik puede involucrar varios de estos conceptos, especialmente si se habla de Transformaciones Lineales.\nLiteratura: # Transformaciones Lineales # Como se puede imaginar, hay una cantidad inimaginablemente enorme de transformaciones posibles, la mayoría de las cuales sería bastante complicado pensar en ellas. Afortunadamente, el álgebra lineal suele estar limitada a un tipo especial de transformación que es más fácil de entender: las transformaciones lineales.\nVisualmente, esto significa que toda la cuadrícula de puntos 2d \u0026ldquo;sigue\u0026rdquo; con î y ĵ, por así decirlo. Puedes saber que una transformación es lineal si todas esas líneas de cuadrícula que comenzaron paralelas y espaciadas uniformemente permanecen paralelas y espaciadas uniformemente (¿por qué?). En realidad, es un poco más limitado que eso. Si una transformación es lineal, también debe fijar el origen en su lugar.\nMatriz de Rotación # Rotación 2D # Rotación 3D # p5.js: # Es una biblioteca de JavaScript para la codificación creativa, con un enfoque en la realización de la codificación accesible e inclusiva para artistas, diseñadores, educadores, principiantes y cualquier otra persona. P5.js es gratuito y de código abierto porque la filosofia de los creadores es que el software, y las herramientas para aprenderlo, deben ser accesibles para todos.(p5js.org)\nReferencias # 3 blue 1 Brown - Linear Transformations\nMetodos # Rubikcube Rubik\u0026rsquo;s Cube # "},{"id":18,"href":"/showcasevc/docs/shortcodes/Transformations/rubikcube/","title":"Rubikcube","section":"Transformations","content":" Rubik\u0026rsquo;s Cube # "}]