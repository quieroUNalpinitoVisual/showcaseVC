[{"id":0,"href":"/showcasevc/docs/shortcodes/Antialiasing/","title":"Antialiasing","section":"Shortcodes","content":" Antialiasing # Se desea trabajar en una implementacion del algoritmo de antialiasing y estudiar sus fenomenos.\n"},{"id":1,"href":"/showcasevc/docs/shortcodes/Antialiasing/AntialiasingLab/","title":"Antialiasing Lab","section":"Antialiasing","content":" Masking Lab # Seccion de pruebas de antialiasing.\nFlecha derecha: Generar nuevo triangulo\nFlecha izquierda: Pasar antialiasing\n"},{"id":2,"href":"/showcasevc/docs/shortcodes/Antialiasing/AntialiasingRes/","title":"Antialiasing Res","section":"Antialiasing","content":" Academic report # Introducci√≥n: # El Antialiasing (suavizado, antiescalonamiento o suavizado de bordes) son un conjunto de tecnicas diferentes las cuales quieren evitar el solapamiento de los bordes debida a representar una se√±al de alta resoluci√≥n en un monitor de baja resoluci√≥n.\nLiteratura: # M√©todos de AA: # Para lograr el efecto del antialiasing se realizan varios m√©todos con distintas aproximaciones:\nSuper sampling:\nBasicamente consiste en realizar un an√°logo de el muestreo de una se√±al analoga y aumentar el muestreo de la misma para obtener mejores datos. Multi-sampling:\nSe parece al algoritmo de super sampling pero difiere con el al momento de calculo de cada pixel, donde en SSAA se realizan varios calculos por pixel, en MSAA se realiza solo un calculo por pixel.\nEdge AA:\nEs un m√©todo propuesto por Deferred Shading en STALKER. En este se realiza primero un calculo de bordes de una imagen y a partir de esto se usa como m√°scara para saber en que lugares se debe realizar el algoritmo de AA. AA Morfol√≥gico:\nEn este m√©todo de dividen las areas de pixeles con colores similares en 3 tipos: Z, L y U. Tanto Z como U se pueden componer de tipos L. Ya con las areas de tipo L distinguidas usa modelado de triangulos para realizar el calculo del antialiasing.\nDeep Learning Super Sample:\nEste algortimo desarrollado por Nvidia hace uso de los subprocesadores de tipo Tensor en las nuevas graficas de la compa√±ia para implementar Super Sampling mediante una IA. AMD FidelityFX Contrast Adaptive Sharpening:\nEste algoritmo de antialiasing temporal es desarrollado por AMD technologies y posee una base de codigo abierto para su uso. Ademas de proveer antialiasing, tambien posee funciones de escalamiento y sharpening.\nImplementaci√≥n # En el apartado de AntialiasingLab se puede encontrar un ejemplo de implementacion de SSAA basado en la facilidad que tenemos de obtener la referencia real de la figura que estamos modelando, en este caso es un tri√°ngulo aleatorio que se dibuja en una cuadrilla.\nEn la funcion que describimos a continuacion en el expandible encontramos los loops que recorren la simulacion de una imagen de mas alta resoluci√≥n (64 a 1) y van hayando donde el triangulo discreto (en este caso dibujado con la funcion de Quadrille.js) y el triangulo real que se dibuja con la primitiva triangle() de p5. Damos un peso relativo de acuerdo a cuantos pixeles de la imagen de alta resolucion poseen el triangulo y lo dibujamos luego en la cuadrilla de menor resoluci√≥n\nExpand ‚Üï p5 code # function supersamp(){ let total = 64; for (let i = 0; i \u0026lt; QUADDIM ; i ++) { for (let j = 0; j \u0026lt; QUADDIM ; j ++) { let count = 0; let si = LENGTH * i +1; let sj = LENGTH * j + 1; for (; si \u0026lt; LENGTH * i + LENGTH - 1 ; si ++) { for (; sj \u0026lt; LENGTH * j + LENGTH - 1 ; sj ++) { if(get(si,sj)[0] != 0){ count += 1; } } } let shade = (count/total)*10; board._memory2D[j][i]=[red(0), green(255*shade), blue(0), alpha(255)]; } } } Resultados # Pre AA\nPost AA\nConclusiones # El algoritmo es capaz de ser paralelizable para un mejor rendimiento. Dada la base tan robusta y sencilla del SS este ha derivado en otros m√©todos como el DLSS. La informaci√≥n inicial deberia ser capaz de obtenerse sin bordes para dibujarlos con AA (QuadrilleJS en los bordes \u0026ldquo;√Ønferiores\u0026rdquo;). Junto con el calculo de bordes daria un muy buen resultado con el algoritmo de Edge AA. Entre mucho mayor sea la resolucion del super sampling, se obtienen profundidades de colores intermedias mas precisas, pero llega un punto en que no se notara la diferencia. Referencias # Algoritmos de antialiasing - Gabriel Ma√±ana Guich√≥n Nvidia DLSS AMD FidelityFx CAS Mas algoritmos de Antialiasing QuadrilleJS\n"},{"id":3,"href":"/showcasevc/docs/shortcodes/Interactions-3D/","title":"Interactions 3 D","section":"Shortcodes","content":" Investigaci√≥n sobre interacci√≥nes de usuario en 3D # (A Survey of Interaction Techniques for Interactive 3D Environments) - Jacek Jankowski, Martin Hachet\nAcademic report # Introducci√≥n: # Teniendo en cuenta la tematica adelantada en clase, y su amplio espectro, decidimos enfocarnos en las interacciones de usuario en 3D. Mas especificamente las interacciones hombre maquina dentro de un espacio virtual simulado en la computadora. Y es que a pesar de que todos hemos crecido y vivido en un entorno 3D y por tanto hemos desarrollado habilidades para interactuar en el mismo, a menudo nos resulta dif√≠cil interacturar en entronos 3D interactivos, y segun Jankowski[1] frecuentemente esto es resultado de una interfaz de usuario mal dise√±ada o debido a una selecci√≥n inadecuada de t√©cnicas de interacci√≥n.\nLiteratura: # Entornos 3D: # Se definen los entornos 3D interactivos como representaciones inform√°ticas del mundo real o espacios imaginarios a trav√©s de los cuales los usuarios pueden navegar y en los que pueden interacturar con objetos en tiempo real. A diferencia de los entornos virtuales inmersivos , que utilizan pantallas especializadas y dispositivos de interacci√≥n, como pantallas montadas en la cabeza, para crear una sensaci√≥n de presencia para los usuarios dentro del mundo virtual, los entornos 3D interactivos no se limitan al contexto inmersivo y aprovechan los recursos comunes y general de hardware, es decir mouse y teclado como multi_touch input.\nTendremos en cuenta la clasificaci√≥n de las interacciones en un ambiente interactivo 3D que encontramos en el libro de Jankowski[1] que habla de 3 tareas de interaccion universales: Navegaci√≥n, Selecci√≥n y manipulaci√≥n, y Control de sistema.\nNavegaci√≥n: # Se refiere a la tarea motora de mover el punto de vista del usuario a trav√©s de un entorno; incluye un componente cognitivo: orientaci√≥n.\nLos entornos 3D interactivos suelen representar m√°s espacio del que se puede ver desde un solo punto. Los usuarios deben poder moverse dentro del entorno para obtener diferentes vistas de la escena. Este proceso de desplazarse por un entorno virtual mientras se realiza un seguimiento del propio paradero y los objetivos de la tarea es el tema de una serie de t√©cnicas a las que a menudo se hace referencia con nombres como orientaci√≥n, locomoci√≥n, navegaci√≥n y c√°mara.\nHay que resaltar que es dif√≠cil desarrollar una t√©cnica eficaz para la navegaci√≥n en entornos 3D interactivos. En primer lugar, el control del punto de vista implica seis grados de libertad (6DOF): tres dimensiones para la ubicaci√≥n posicional (traslaci√≥n) y tres para la ubicaci√≥n angular (rotaci√≥n).\nSegun algunas literaturas podemos agrupoar 4 tipos de movimiento de punto de vista para espacios de trabajo 3D interactivos:\nMovimiento general: Movimiento exploratorio, como caminar a trav√©s de una simulaci√≥n de un dise√±o arquitect√≥nico\nMovimiento dirigido: Movimiento con respecto a un objetivo espec√≠fico, como moverse para examinar un detalle de un modelo de ingenier√≠a.\nMovimiento de coordenadas especificado: Movimiento a una posici√≥n y orientaci√≥n precisas, como una posici√≥n de visualizaci√≥n espec√≠fica en relaci√≥n con un modelo CAD: el usuario debe proporcionar la posici√≥n y orientaci√≥n exactas de su destino.\nMovimiento de trayectoria especificado: Movimiento a lo largo de una trayectoria de posici√≥n y orientaci√≥n, como el movimiento de una c√°mara cinematogr√°fica (corresponde al objetivo Maniobra de Bowman et al. y al objetivo Inspecci√≥n de Tan et al.).\nSelecci√≥n y manipulaci√≥n: # Otra tarea t√≠pica que se realiza en un entorno virtual 3D es la selecci√≥n de objetos y su manipulaci√≥n directa mediante la especificaci√≥n su posici√≥n, orientaci√≥n y escala. Encontramos que las t√©cnicas de interacci√≥n mas comunes en la literatura para la manipulaci√≥n 3D incluyen tres tareas fundamentales: traducci√≥n de objetos (posicionamiento), rotaci√≥n de objetos y escalado de objetos. Las t√©cnicas de interacci√≥n para la manipulaci√≥n 3D incluyen tres tareas fundamentales: traducci√≥n de objetos (posicionamiento), rotaci√≥n de objetos y escalado de objetos.\nSeleccion de objetos: # La forma m√°s com√∫n de seleccionar objetos en los VE de escritorio es colocar el cursor del mouse sobre un objeto dado y hacer clic en un bot√≥n del mouse. La t√©cnica se basa en la proyecci√≥n de rayos (ray casting); utiliza el rayo desde el punto del ojo a trav√©s del p√≠xel actualmente seleccionado por el puntero del mouse para encontrar el primer punto de intersecci√≥n con la escena (la superficie del objetivo o su superficie aproximada, por ejemplo, el cuadro delimitador). Si el rayo virtual se cruza con un objeto, se puede seleccionar para una mayor manipulaci√≥n.\nManipulaci√≥n de objeto: # La manipulaci√≥n de objetos es otra tarea b√°sica que se realiza en un entorno virtual 3D, especialmente durante la construcci√≥n de escenas. Al dise√±ar una escena con m√∫ltiples objetos, los usuarios tienen que realinear y ajustar varias partes repetidamente. Es importante proporcionar una t√©cnica de manipulaci√≥n de objetos eficiente.\nControl del sistema: # Se refiere a la comunicaci√≥n entre el usuario y el sistema que no forma parte del entorno virtual.\nSe puede enfocar en una tarea en la que se aplica un comando para cambiar el estado del sistema o el modo de interacci√≥n .Se se√±ala que aunque el movimiento del punto de vista y la selecci√≥n/manipulaci√≥n se han estudiado ampliamente, se ha investigado muy poco sobre las tareas de control del sistema. Sin embargo, las t√©cnicas de control de aplicaciones se han estudiado intensamente durante los √∫ltimos 40 a√±os en las interfaces gr√°ficas de usuario WIMP 2D \u0026ldquo;apuntar y hacer clic\u0026rdquo; (interfaces basadas en ventanas, √≠conos, men√∫s y un dispositivo se√±alador, generalmente un mouse).\n# Metodos # "},{"id":4,"href":"/showcasevc/docs/shortcodes/masking/","title":"Masking","section":"Shortcodes","content":" Masking # En esta tem√°tica se desarroll√≥ un entorno de ejecuci√≥n para visualizar los efectos de algunos kernels en matrices de convolucion sobre imagenes para su posterior uso como base en un algoritmo que calcula los bordes de las mismas im√°genes mediante derivadas parciales en dos variables.\n"},{"id":5,"href":"/showcasevc/docs/shortcodes/masking/maskingLab/","title":"Masking Lab","section":"Masking","content":" Masking Lab # Seccion de pruebas de matrices de convolucion como paso intermedio para el c√°lculo de bordes mediante derivadas parciales.\n"},{"id":6,"href":"/showcasevc/docs/shortcodes/masking/maskingRes/","title":"Masking Res","section":"Masking","content":" Masking Results # Conceptos # Lo primero que se realiz√≥ fue programar la funci√≥n que permitir√° la convoluci√≥n de un kernel sobre una imagen de acuerdo con lo encontrado en wikipedia\nExpand ‚Üï Wiki pseudocode # for each image row in input image: for each pixel in image row: set accumulator to zero for each kernel row in kernel: for each element in kernel row: if element position corresponding* to pixel position then multiply element value corresponding* to pixel value add result to accumulator endif set output image pixel to accumulator la implementaci√≥n concreta es la siguiente\nExpand ‚Üï p5 code # p.convolute = function (matrix){ img.loadPixels(); let rtotal = 0.0; let gtotal = 0.0; let btotal = 0.0; let postconv = p.createImage(400,400); for (let i = 1; i \u0026lt; 399; i++){ for (let j = 1; j \u0026lt; 399; j++){ rtotal = 0.0; gtotal = 0.0; btotal = 0.0; for (let k = -1; k \u0026lt;= 1; k++){ for (let l = -1; l \u0026lt;= 1; l++){ let xpos = i+k; let ypos = j+l; let red = p.red(img.get(xpos,ypos)); let green = p.green(img.get(xpos,ypos)); let blue = p.blue(img.get(xpos,ypos)); rtotal += red * matrix[k+1][l+1]; gtotal += green * matrix[k+1][l+1]; btotal += blue * matrix[k+1][l+1]; } } rtotal = p.constrain(rtotal, 0, 255); gtotal = p.constrain(gtotal, 0, 255); btotal = p.constrain(btotal, 0, 255); let c = p.color(rtotal,gtotal,btotal); postconv.set(i,j,c); } } postconv.updatePixels(); img = postconv; img.updatePixels(); p.square(0,200,400); p.drawimg(img,0,200); console.log('convolucion realizada! :D'); } Una derivada parcial nos indica como se mueve la pendiente en ese punto para la funcion (imagen)\nhttps://mathinsight.org/partial_derivative_limit_definition\ncodigo de detecci√≥n de bordes:\nExpand ‚Üï p5 code # p.calcborders = function(){ let prebord = p.createImage(400,400); for (let i = 0; i \u0026lt; 400; i++) { for (let j = 0; j \u0026lt; 400; j++) { let g = (p.red(img.get(i,j))+p.green(img.get(i,j))+p.blue(img.get(i,j)))/3; prebord.set(i,j,g); } } let med = [0,0,0,0,0,0,0,0,0]; for (let r = 0; r \u0026lt; 3; r++) { for (let i = 1; i \u0026lt; 400-1; i++) { for (let j = 1; j \u0026lt; 400-1; j++) { med[0] = prebord.get(i - 1,j - 1); med[1] = prebord.get(i,j - 1); med[2] = prebord.get(i + 1,j - 1); med[3] = prebord.get(i - 1,j); med[4] = prebord.get(i,j); med[5] = prebord.get(i + 1,j); med[6] = prebord.get(i - 1,j + 1); med[7] = prebord.get(i,j + 1); med[8] = prebord.get(i + 1,j + 1); med.sort(); prebord.set(i,j,med[4]); } } } let gradx = p.zeroes([400,400]); let grady = p.zeroes([400,400]); for (let i = 0; i \u0026lt; 400-1; i++) { for (let j = 0; j \u0026lt; 400-1; j++) { gradx[i][j] = p.red(img.get(i+1,j)) - p.red(img.get(i,j)); grady[i][j] = p.red(img.get(i,j+1)) - p.red(img.get(i,j)); } } let gradmag = p.zeroes([400,400]); let gradang = p.zeroes([400,400]); for (let i = 0; i \u0026lt; 400-1; i++) { for (let j = 0; j \u0026lt; 400-1; j++) { gradmag[i][j]= p.abs(p.sqrt((gradx[i][j]*gradx[i][j])+(grady[i][j]*grady[i][j]))); gradang[i][j]= p.atan2(grady[i][j],gradx[i][j]); } } let borders = p.zeroes([400,400]); for (let i = 1; i \u0026lt; 400-1; i++) { for (let j = 1; j \u0026lt; 400-1; j++) { if (gradang[i][j] \u0026gt; 0 \u0026amp;\u0026amp; gradang[i + 1][j] \u0026lt; 0) { borders[i][j] = 1; } else if (gradang[i][j] \u0026lt; 0 \u0026amp;\u0026amp; gradang[i + 1][j] \u0026gt; 0) { borders[i][j] = 1; } else if (gradang[i][j] \u0026gt; 0 \u0026amp;\u0026amp; gradang[i][j + 1] \u0026lt; 0) { borders[i][j] = 1; } else if (gradang[i][j] \u0026lt; 0 \u0026amp;\u0026amp; gradang[i][j + 1] \u0026gt; 0) { borders[i][j] = 1; } } } for (let i = 1; i \u0026lt; 400-1; i++) { for (let j = 1; j \u0026lt; 400-1; j++) { if( borders[i][j-1] == 0 \u0026amp;\u0026amp; borders[i-1][j] == 0 \u0026amp;\u0026amp; borders[i+1][j] == 0 \u0026amp;\u0026amp; borders[i][j+1] == 0 ){ borders[i][j] = 0; } } } let postbord = p.createImage(400,400); for (let i = 0; i \u0026lt; 400; i++) { for (let j = 0; j \u0026lt; 400; j++) { if (borders[i][j] == 1) { //postbord.set(i, j, p.color(0,0,0)); postbord.set(i, j, p.color(255,255,255)); } else { //postbord.set(i, j, p.color(255,255,255)); postbord.set(i, j, p.color(0,0,0)); } } } postbord.updatePixels(); console.log(prebord); console.log(postbord); bord = postbord; p.image(bord, 0, 650,400,400); } Imagenes convolucionadas y bordes # Los siguientes resultados poseen un error en la funcion de convolucion que intercambia el valor de verdes por azules y viceversa, visible en el resultado de la convoluci√≥n, pero esto mismo debido a que es una permutaci√≥n no afecta el calculo de bordes el cual se hace a partir de la imagen en escala de grises.\nimagen base: # identidad / sin mascara : # sharpen : # ridge : # box blur: # composition: # "},{"id":7,"href":"/showcasevc/docs/shortcodes/members/","title":"Members","section":"Shortcodes","content":" Members # Nicholson Stive Ochoa # Estudiante de Ingenieria de Sistemas y Computacion en la Universidad Nacional de Colombia.\nIntereses ü§î # Acad√©micos üìò Desarrollo web Inteligencia artificial Desarrollo en multiplataforma Pasatiempos üéÆüé∏ Ver anime y series Hacer ejercicio Daniel Arturo Moreno # Estudiante de Ingenieria de Sistemas y Computacion en la Universidad Nacional de Colombia.\nIntereses ü§î # Acad√©micos üìò\nDesarrollo Web Arduino Linux Procesamiento de im√°genes Programaci√≥n Competitiva y Algoritmia Pasatiempos üéÆüé∏\nGeoguessr RPGs M√∫sica Johan Sebastian Romero # Estudiante de Ingenieria de Sistemas y Computacion en la Universidad Nacional de Colombia.\nIntereses ü§î # Acad√©micos üìò\nDesarrollo Web Procesamiento de imagenes Arquitectura de software Pasatiempos üéÆüé∏\nVideojuegos (Wow) Motociclismo off road Anime "},{"id":8,"href":"/showcasevc/docs/shortcodes/shadersJohanRomero/","title":"Shaders Johan Romero","section":"Shortcodes","content":" Shaders Johan Sebastian Romero Diaz # seccion para los ejercicios propuestos para la seccion final del curso\n"},{"id":9,"href":"/showcasevc/docs/shortcodes/shadersJohanRomero/imageProcessing/","title":"Image Processing","section":"Shaders Johan Romero","content":" Image Processing # "},{"id":10,"href":"/showcasevc/docs/shortcodes/shadersJohanRomero/proceduralTexturing/","title":"Procedural Texturing","section":"Shaders Johan Romero","content":" Procedural texturing # "},{"id":11,"href":"/showcasevc/docs/shortcodes/shadersJohanRomero/texturing/","title":"Texturing","section":"Shaders Johan Romero","content":" Texturing # "},{"id":12,"href":"/showcasevc/docs/shortcodes/terrain/","title":"Terrain","section":"Shortcodes","content":" Creating a terrain with p5.js # Academic report # Introducci√≥n: # En el marco de trabajo presentado por el profesor en clase, que enmarcaba varios tipos de ilusiones, nos llam√≥ la atenci√≥n el titulado MACH BANDS , el cual se enfocaba en la generaci√≥n de un terreno con una superficie natural con la aplicaci√≥n del efecto nombrado.\nPara lograr el objetivo utilizamos la libreria p5.js, la cual utilizaremos posiblemente durante los proyectos del semestre por recomendaci√≥n del profesor y no valemos de una libreria integrada de p5 llamada Perlin noise para tratar de generar una textura natural para el terreno.\nLiteratura: # p5.js: # Es una biblioteca de JavaScript para la codificaci√≥n creativa, con un enfoque en la realizaci√≥n de la codificaci√≥n accesible e inclusiva para artistas, dise√±adores, educadores, principiantes y cualquier otra persona. P5.js es gratuito y de c√≥digo abierto porque la filosofia de los creadores es que el software, y las herramientas para aprenderlo, deben ser accesibles para todos.(p5js.org)\nPerlin noise # Es un generador de secuencias aleatorias que produce una sucesi√≥n de n√∫meros arm√≥nicos ordenados de forma m√°s natural en compraci√≥n con la funci√≥n est√°ndar aleatoria (). Fue inventado por Ken Perlin en la d√©cada de 1980 y se ha utilizado desde aplicaciones gr√°ficas para producer textura de procedimiento, movimiento natural, formas, terrenos, etc. (p5js.org)\nLa mayor diferencia con random() es que perlin noise se define en un espacio N-dimensional infinito donde cada par de coordenadas corresponde a un valor semi-aleatorio fijo.\nMetodos # Terrain1 Terrain # En el primer terreno creado usamos TRIANGLE_STRIP como parametro para la funci√≥n beginShape() Terrain2 Terrain # En esta iteraci√≥n se hace uso del efecto de la banda de Mach para representar una ilusion de gradiente en la visualizaci√≥n del terreno. Terrain3 Terrain # Por ultimo utilizamos el parametro TRIANGLE_FAN. Terrain Res #Terrain Con TRIANGLE_STRIP la figura a manejar es mas grande y por ende se utilizan menos recursos. Pero el relleno es mas complicado. Con la ilusion generada por la banda de Mach encontramos un rendimiento aceptable. El efecto de relleno visual es natural exceptuando nuestro enfasis al marcar los bordes. Con TRIANGLE_FAN la figura a manejar es mas peque√±a y por ende se utilizan mas recursos. Pero el relleno es mas detallado y natural. "},{"id":13,"href":"/showcasevc/docs/shortcodes/terrain/terrain1/","title":"Terrain1","section":"Terrain","content":" Terrain # En el primer terreno creado usamos TRIANGLE_STRIP como parametro para la funci√≥n beginShape()\n"},{"id":14,"href":"/showcasevc/docs/shortcodes/terrain/terrain2/","title":"Terrain2","section":"Terrain","content":" Terrain # En esta iteraci√≥n se hace uso del efecto de la banda de Mach para representar una ilusion de gradiente en la visualizaci√≥n del terreno.\n"},{"id":15,"href":"/showcasevc/docs/shortcodes/terrain/terrain3/","title":"Terrain3","section":"Terrain","content":" Terrain # Por ultimo utilizamos el parametro TRIANGLE_FAN.\n"},{"id":16,"href":"/showcasevc/docs/shortcodes/terrain/terrainRes/","title":"Terrain Res","section":"Terrain","content":"#Terrain\nCon TRIANGLE_STRIP la figura a manejar es mas grande y por ende se utilizan menos recursos.\nPero el relleno es mas complicado.\nCon la ilusion generada por la banda de Mach encontramos un rendimiento aceptable.\nEl efecto de relleno visual es natural exceptuando nuestro enfasis al marcar los bordes.\nCon TRIANGLE_FAN la figura a manejar es mas peque√±a y por ende se utilizan mas recursos.\nPero el relleno es mas detallado y natural.\n"},{"id":17,"href":"/showcasevc/docs/shortcodes/Transformations/","title":"Transformations","section":"Shortcodes","content":" Creating a Matrix Transformation based cube with p5.js # Academic report # Introducci√≥n: # Durante el desarrollo del workshop, buscamos una manera did√°ctica de llevar a cabo una representaci√≥n gr√°fica de la implementaci√≥n de transformaciones matriciales, y finalmente se plante√≥ que un Cubo de Rubik puede involucrar varios de estos conceptos, especialmente si se habla de Transformaciones Lineales.\nLiteratura: # Transformaciones Lineales # Como se puede imaginar, hay una cantidad inimaginablemente enorme de transformaciones posibles, la mayor√≠a de las cuales ser√≠a bastante complicado pensar en ellas. Afortunadamente, el √°lgebra lineal suele estar limitada a un tipo especial de transformaci√≥n que es m√°s f√°cil de entender: las transformaciones lineales.\nVisualmente, esto significa que toda la cuadr√≠cula de puntos 2d \u0026ldquo;sigue\u0026rdquo; con √Æ y ƒµ, por as√≠ decirlo. Puedes saber que una transformaci√≥n es lineal si todas esas l√≠neas de cuadr√≠cula que comenzaron paralelas y espaciadas uniformemente permanecen paralelas y espaciadas uniformemente (¬øpor qu√©?). En realidad, es un poco m√°s limitado que eso. Si una transformaci√≥n es lineal, tambi√©n debe fijar el origen en su lugar.\nMatriz de Rotaci√≥n # Rotaci√≥n 2D # Rotaci√≥n 3D # p5.js: # Es una biblioteca de JavaScript para la codificaci√≥n creativa, con un enfoque en la realizaci√≥n de la codificaci√≥n accesible e inclusiva para artistas, dise√±adores, educadores, principiantes y cualquier otra persona. P5.js es gratuito y de c√≥digo abierto porque la filosofia de los creadores es que el software, y las herramientas para aprenderlo, deben ser accesibles para todos.(p5js.org)\nReferencias # 3 blue 1 Brown - Linear Transformations\nMetodos # Rubikcube Rubik\u0026rsquo;s Cube # "},{"id":18,"href":"/showcasevc/docs/shortcodes/Transformations/rubikcube/","title":"Rubikcube","section":"Transformations","content":" Rubik\u0026rsquo;s Cube # "}]